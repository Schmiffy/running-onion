<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Running Onion</title>
  <style>
    html, body { margin:0; padding:0; background:#f7f7f7; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { display:grid; place-items:center; height:100vh; }
    canvas { background:#fff; box-shadow: 0 10px 30px rgba(0,0,0,.08); image-rendering: pixelated; border:1px solid #e5e5e5; }
    .hud { position: fixed; top: 14px; right: 16px; font-size: 14px; color:#444 }
    .hud b { font-weight:600; }
    .help { position: fixed; bottom: 14px; left: 16px; font-size: 13px; color:#666 }
    .btn { appearance:none; border:1px solid #d0d0d0; padding:6px 10px; background:#fff; border-radius:6px; cursor:pointer; font-size:13px }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="270" aria-label="Running Onion game"></canvas>
  </div>
  <div class="hud"><b>Score:</b> <span id="score">0</span>&nbsp;&nbsp; <b>HI:</b> <span id="hiscore">0</span></div>
  <div class="help">Jump: Space / ↑ / W / Tap • Restart: R • Pause: P</div>
<script>
(function(){
  const W = 960, H = 270; // same vibe as Chrome Dino
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hiscore');
  const HI_KEY = 'running-onion-hi';
  let hiScore = +localStorage.getItem(HI_KEY) || 0; hiEl.textContent = hiScore;

  // ------- Pixel art sprites (16x16, scaled) -------
  // Palette indices -> RGBA
  const PAL = {
    0: [0,0,0,0],            // transparent
    1: [40,40,40,255],       // outline
    2: [160,226,105,255],    // onion light
    3: [102,170,61,255],     // onion mid
    4: [70,120,40,255],      // onion dark
    5: [205,155,65,255],     // root
    6: [230,230,230,255],    // eye white
    7: [45,45,45,255],       // eye dark
    8: [180,180,180,255],    // shadow/ground mark
  };

  // Helper: create ImageData from 16x16 matrix of palette indices
  function makeSprite(grid){
    const s = 16, data = ctx.createImageData(s, s);
    for (let y=0; y<s; y++){
      for (let x=0; x<s; x++){
        const idx = (y*s + x) * 4;
        const c = PAL[grid[y][x] || 0];
        data.data[idx+0] = c[0];
        data.data[idx+1] = c[1];
        data.data[idx+2] = c[2];
        data.data[idx+3] = c[3];
      }
    }
    // draw to an offscreen canvas so we can scale cleanly later
    const off = document.createElement('canvas');
    off.width = off.height = s; const ictx = off.getContext('2d');
    ictx.putImageData(data,0,0);
    return off;
  }

  // Onion frames: idle/run1/run2/duck
  // Simple circular bulb with sprout, tiny face; two run frames shift legs/leaf.
  const ONION_IDLE = makeSprite([
    [0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,3,2,2,3,0,0,0,0,0,0],
    [0,0,0,0,0,3,2,2,2,2,3,0,0,0,0,0],
    [0,0,0,0,3,2,2,2,2,2,2,3,0,0,0,0],
    [0,0,0,3,2,2,2,2,2,2,2,2,3,0,0,0],
    [0,0,3,2,2,2,2,6,6,2,2,2,2,3,0,0],
    [0,3,2,2,2,2,7,7,7,7,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,7,7,2,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,2,3,0],
    [0,0,3,2,2,2,2,2,2,2,2,2,2,3,0,0],
    [0,0,0,3,2,2,2,2,2,2,2,2,3,0,0,0],
    [0,0,0,0,3,2,2,2,2,2,2,3,0,0,0,0],
    [0,0,0,0,0,3,2,2,2,2,3,0,0,0,0,0],
    [0,0,0,0,0,0,1,5,5,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
  ]);

  const ONION_RUN1 = makeSprite([
    [0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,3,2,2,3,0,0,0,0,0,0],
    [0,0,0,0,0,3,2,2,2,2,3,0,0,0,0,0],
    [0,0,0,0,3,2,2,2,2,2,2,3,0,0,0,0],
    [0,0,0,3,2,2,2,2,2,2,2,2,3,0,0,0],
    [0,0,3,2,2,2,2,6,6,2,2,2,2,3,0,0],
    [0,3,2,2,2,2,7,7,7,7,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,7,7,2,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,2,3,0],
    [0,0,3,2,2,2,2,2,2,2,2,2,2,3,0,0],
    [0,0,0,3,2,2,2,2,2,2,2,2,3,0,0,0],
    [0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0], // little forward foot
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,5,5,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
  ]);

  const ONION_RUN2 = makeSprite([
    [0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,3,2,2,3,0,0,0,0,0,0],
    [0,0,0,0,0,3,2,2,2,2,3,0,0,0,0,0],
    [0,0,0,0,3,2,2,2,2,2,2,3,0,0,0,0],
    [0,0,0,3,2,2,2,2,2,2,2,2,3,0,0,0],
    [0,0,3,2,2,2,2,6,6,2,2,2,2,3,0,0],
    [0,3,2,2,2,2,7,7,7,7,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,7,7,2,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,2,3,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,2,3,0],
    [0,0,3,2,2,2,2,2,2,2,2,2,2,3,0,0],
    [0,0,0,3,2,2,2,2,2,2,2,2,3,0,0,0],
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0], // back foot
    [0,0,0,0,0,0,1,5,5,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
  ]);

  const ONION_DUCK = makeSprite([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,3,2,2,2,3,0,0,0,0,0,0],
    [0,0,0,0,3,2,2,2,2,2,3,0,0,0,0,0],
    [0,0,0,3,2,2,2,2,2,2,2,3,0,0,0,0],
    [0,0,3,2,2,2,6,6,2,2,2,2,3,0,0,0],
    [0,3,2,2,2,2,7,7,7,7,2,2,2,3,0,0],
    [0,3,2,2,2,2,2,7,7,2,2,2,2,3,0,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,3,0,0],
    [0,3,2,2,2,2,2,2,2,2,2,2,2,3,0,0],
    [0,0,3,2,2,2,2,2,2,2,2,2,3,0,0,0],
    [0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0],
    [0,0,0,0,0,0,1,5,5,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  ]);

  // Cactus-like obstacle 16x22 and a low bird (optional later)
  const CACTUS = makeSprite([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,3,3,1,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0],
    [0,0,0,0,0,1,1,3,3,3,3,1,1,0,0,0],
    [0,0,0,0,0,3,3,3,3,3,3,3,3,0,0,0],
    [0,0,0,0,0,3,3,3,3,3,3,3,3,0,0,0],
    [0,0,0,0,0,1,1,3,3,3,3,1,1,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0],
  ]);

  // ------- Game state -------
  const state = {
    playing: false,
    paused: false,
    t: 0,
    speed: 6,
    gravity: 0.8,
    jump: -13.2,
    floorY: 220,
    score: 0,
    day: true,
  };

  const player = {
    x: 80,
    y: 0,
    w: 44,
    h: 44,
    vy: 0,
    onGround: true,
    ducking: false,
    animTimer: 0,
    frame() {
      if (this.ducking && this.onGround) return ONION_DUCK;
      if (!this.onGround) return ONION_RUN1;
      return (Math.floor(this.animTimer / 8) % 2 === 0) ? ONION_RUN1 : ONION_RUN2;
    }
  };
  player.y = state.floorY - player.h;

  const groundMarks = []; // scrolling ground dots
  const obstacles = [];

  function reset(){
    state.playing = true;
    state.paused = false;
    state.t = 0;
    state.speed = 6;
    state.score = 0;
    state.day = true;
    player.vy = 0; player.onGround = true; player.ducking = false; player.animTimer = 0; player.y = state.floorY - player.h;
    obstacles.length = 0; groundMarks.length = 0;
    for(let x=0; x<W; x+= 12){ groundMarks.push({x, y: state.floorY + 18 + ((x/12)%2?0:2)}); }
  }

  function spawnObstacle(){
    const tall = Math.random() > 0.6 ? 2 : 1; // sometimes double cactus
    const width = 16 * tall;
    const height = 32 + Math.floor(Math.random()*8);
    obstacles.push({
      x: W + 20,
      y: state.floorY - height,
      w: width,
      h: height,
      type: 'cactus',
      sprite: CACTUS,
      scale: tall === 2 ? 3 : 2
    });
  }

  // Input
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyP') state.paused = !state.paused;
    if (!state.playing && (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'KeyR')) reset();
    if (state.playing && !state.paused && (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW')) jump();
    if (e.code === 'ArrowDown' || e.code === 'KeyS') player.ducking = true;
    if (e.code === 'KeyR') { reset(); }
  });
  window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') player.ducking = false;
  });
  // Touch
  canvas.addEventListener('pointerdown', () => { if(!state.playing) reset(); else jump(); });

  function jump(){
    if (player.onGround){ player.vy = state.jump; player.onGround = false; }
  }

  // Drawing helpers
  function drawSprite(img, x, y, scale){
    const s = scale || 3; // default scale
    const destW = img.width * s;
    const destH = img.height * s;
    ctx.drawImage(img, Math.floor(x), Math.floor(y), destW, destH);
  }

  function drawGround(){
    ctx.fillStyle = state.day ? '#e0e0e0' : '#303030';
    ctx.fillRect(0, state.floorY + 44, W, 1);
    ctx.fillRect(0, state.floorY + 30, W, 1);
    ctx.fillStyle = state.day ? '#bdbdbd' : '#505050';
    groundMarks.forEach(g => { ctx.fillRect(Math.floor(g.x), g.y, 2, 2); });
  }

  function drawClouds(t){
    ctx.fillStyle = state.day ? '#dcdcdc' : '#2a2a2a';
    const yBase = 50;
    for (let i=0;i<3;i++){
       const x = (W - ((t*0.5 + i*260) % (W+200)));
       ctx.fillRect(x, yBase + i*18, 38, 10);
       ctx.fillRect(x+10, yBase - 6 + i*18, 18, 10);
       ctx.fillRect(x+22, yBase + 2 + i*18, 22, 10);
    }
  }

  function drawUI(){
    scoreEl.textContent = state.score.toString().padStart(5,'0');
    if (!state.playing){
      ctx.fillStyle = '#333';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Running Onion', W/2, 86);
      ctx.fillText('Press Space / Tap to start', W/2, 110);
      ctx.fillText('Avoid the cacti. Stay low to duck.', W/2, 132);
      ctx.textAlign = 'left';
    }
    if (state.paused){
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='18px Arial';
      ctx.fillText('Paused', W/2, H/2);
      ctx.textAlign='left';
    }
  }

  function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  function update(){
    if (!state.playing || state.paused) return;
    state.t++;

    // Difficulty ramp
    if (state.speed < 13) state.speed += 0.0009; // slow ramp
    if (state.t % 900 === 0) state.day = !state.day; // day-night toggle

    // Player physics
    player.vy += state.gravity;
    player.y += player.vy;
    const targetH = player.ducking && player.onGround ? 36 : 44;
    player.h += Math.sign(targetH - player.h) * 1; // ease height change

    if (player.y + player.h >= state.floorY){
      player.y = state.floorY - player.h; player.vy = 0; player.onGround = true; }

    player.animTimer++;

    // Spawn obstacles with spacing dependent on speed
    if (state.t === 1 || (Math.random() < 0.02 && (obstacles.length === 0 || W - obstacles[obstacles.length-1].x > 220))){
      spawnObstacle();
    }

    // Move obstacles and check collision
    for (let i=obstacles.length-1; i>=0; i--){
      const o = obstacles[i];
      o.x -= state.speed;
      // collision box uses visual size scaled
      const scale = o.scale || 2;
      const box = { x:o.x, y:o.y, w:o.sprite.width*scale, h:o.sprite.height*scale };
      const pbox = { x:player.x+6, y:player.y+6, w:player.w-12, h:player.h-12 };
      if (aabb(pbox, box)) {
        // Game over
        state.playing = false;
        hiScore = Math.max(hiScore, state.score);
        localStorage.setItem(HI_KEY, hiScore);
        hiEl.textContent = hiScore;
      }
      if (o.x + box.w < 0) obstacles.splice(i,1);
    }

    // Scroll ground marks
    groundMarks.forEach(g => { g.x -= state.speed; if (g.x < -10) g.x += W + 20; });

    state.score += Math.floor(state.speed * 0.6);
  }

  function render(){
    // sky
    ctx.fillStyle = state.day ? '#ffffff' : '#111111';
    ctx.fillRect(0,0,W,H);

    drawClouds(state.t);

    // ground line and marks
    drawGround();

    // draw obstacles
    obstacles.forEach(o => { drawSprite(o.sprite, o.x, o.y, o.scale); });

    // draw player
    const frame = player.frame();
    drawSprite(frame, player.x, player.y, 3);

    // subtle shadow
    ctx.fillStyle = state.day ? 'rgba(0,0,0,0.08)' : 'rgba(255,255,255,0.08)';
    ctx.fillRect(player.x+8, state.floorY+34, 32, 3);

    drawUI();

    if (!state.playing){
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Press R to restart', W/2, 156);
      ctx.textAlign = 'left';
    }
  }

  function loop(){ update(); render(); requestAnimationFrame(loop); }

  reset();
  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
